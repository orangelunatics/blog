<h2 style="text-align: center;">talking about Vue.js diff</h2>

- 框架是在性能和可维护性之间取一个平衡，用原生的写法性能肯定好(前提也是复用 DOM)，但代码极其复杂，不利于维护
- 原始的 diff 是 On³ 复杂度，遍历两棵树是 On²，找到需要 patch 的 node，再根据这些 node 去旧的 vnode 中进行移动。因此现代的框架都优化到了 On(同层级)

## 简单 diff

核心：用新的一组子节点中的节点去旧的一组子节点中寻找可复用的阶段，找到则记录该节点的索引，记为**最大索引**，在更新过程中，如果节点的索引小于最大索引，说明需要移动

1. 遍历新旧两组子节点中数量较少的那一组，逐个调用 patch 函数进行打补丁
2. 比较新旧两组子节点数量，新的子节点更多，则说明有新子节点需要挂载
3. 如果旧的子节点更多，说明需要卸载
4. 引入了 key 属性，通过 key 属性找到可复用的节点，尽可能通过 DOM 的移动来完成更新(移动)，注意在移动前也是要进行 patch 打补丁

## 双端 diff(Vue2)

优势：相对简单 diff 算法，对于同样的更新场景，执行 DOM 移动操作次数更少

- 简单 diff 的问题在于，DOM 的移动操作不一定是最优的，操作次数更多
- 四个索引值，分别指向新旧两组子节点的端点，每一轮都进行四次比较

## 快速 diff(Vue3)

在实测中性能最优

1. 借鉴文本 diff 的预处理思路，处理新旧两组子节点中相同的前置节点和相同的后置节点
2. 通过挂载新节点或卸载不存在的节点进行更新，如果还不能处理则 ↓
3. 构造最长递增子序列，该序列指向的节点是不需要移动的节点。具体为构造 source 数组，保存新的节点在旧的一组子节点中的位置，从而找到最长递增子序列，不在 source 数组里的元素才需要移动

TODO:

- react 漫谈
- nuxt 入门
