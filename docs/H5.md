## HTML 的一些细节

[XHTML & !doctype html](https://www.jianshu.com/p/e36462b30bb4)  
当你申明文档类型!DOCTYPE html 后，它默认是标准盒子模型，也就是 box-sizing:content-box。

## img 标签

[alt 和 title 区别](https://blog.csdn.net/u012436704/article/details/83588615)

## 鼠标事件和键盘事件顺序

1、鼠标：mousedown -> mouseup -> click，注：前两个事件可以由任意鼠标按键触发，click 只能左键  
2、键盘：keydown -> keypress -> keyup，注：中间的 press 在 chrome 下，功能键不会触发，比如上下左右。其余两个任意触发。  
3、补充移动端事件：touchstart、touchmove、touchend

## 明水印和暗水印

[详细](https://juejin.cn/post/6900713052270755847#heading-6)  
1、明水印：肉眼可见。  
2、暗水印：肉眼不可见  
比如可以利用 RGB 通道细微变化不影响原图，算法加密解密还原水印。

## 瀑布流

[详细](https://sluggishpj.github.io/blog/2017/10/16/waterfall-flow-principle/#more)

## 移动端 300ms 延迟

1. [fastclick](https://www.cnblogs.com/zuobaiquan01/p/10221810.html)  
   click 事件在 touchend 事件之后 300ms 执行，那么可以监听 touchend 事件，创建一个新的 click 事件去执行，并且禁止 300ms 后的 click 事件执行。
2. user-scalable=no

## PV UV

0-24h 内：  
PV 页面总曝光量 刷新+1  
UV 独立访客

## event.stopImmediatePropagation()

除了能阻止冒泡，还能阻止该事件的后续其他回调执行。(比如注册了同一事件的其他回调)

## 合成层

修改一个既不需要布局也不需要绘制的属性，那么渲染引擎将会跳过布局与绘制，只执行后续的合成操作，这个过程就是合成。

## 全屏样式

```css
div {
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  background-color: #000;
}
```

## DOM 增删改查

1、增：Node.appendChild(newNode):在最后加入子节点、Node.insertBefore(newNode, oneNode):在某个元素之前加入子节点  
2、删：removeChild() list.removeChild(list.childNodes[0]); 删除指定的子节点
3、改：修改元素属性：src、title 等; 修改样式：style; 修改元素内容：innerHTML、innerText  
4、查：getElementByTagName、getElementById、querySelector、querySelectorAll

## Canvas & WebGL

Canvas API 主要聚焦于 2D 图形。  
同样使用 canvas 元素的 WebGL API 则用于绘制硬件加速的 2D 和 3D 图形。
Eva.js 基于 Pixi.js, 基于 WebGL 的 2D 游戏引擎, 为什么要封装成 Eva, 与 React 配套, 封装了很多做动画元素的 hooks, 使用简单。使用 Pixi 是因为其体积小, 渲染能力强；封装他是因为为了社区更简单地是使用他。

## link rel

1、prefetch: 预抓取(下载), 浏览器空闲时刻执行  
2、preload: 预加载, 高优先级, 让浏览器尽可能快的下载资源  
3、prerender: 优先级比 fetch 大, 不仅仅会下载对应的资源，还会对资源进行解析。  
[补充](https://zhuanlan.zhihu.com/p/24460877)

## 图片格式

普通的做法：需要动画则使用 gif, 不需要则选 png 或 jpg, 前者是无损压缩, 细节清晰, 后者相反  
[补充](https://mp.weixin.qq.com/s/gIDq9IyDs2N9Z8eDGBAKQQ)  
webp 特点: 同等画质体积小, 支持动画, 支持有损和无损两种, 缺点: 兼容性。

## 搜索框的节流和防抖

1、如果想要输入完之后再提示，用防抖  
2、如果想要输入过程中就及时提示，用节流

## width/height 继承问题

[width](https://www.cnblogs.com/chenshanyuanzi/p/7698867.html)  
[height](https://segmentfault.com/a/1190000012707337)

## display、visibility、opacity

1、重排重绘：display 发生重排重绘，第二个只发生重绘，第三个会提升为合成层，不会重排重绘  
2、占位：display 不占据位置，后两者占据  
3、事件监听：opacity 为 0 时也可以进行事件监听，其余两者不可以  
4、继承：后两者会继承，display 不会，但后代也不会渲染

## 浏览器的多进程设计

- 进程的隔离性来实现对 App 的隔离。这样用户就不用担心：

1. 一个 Web App 挂掉造成其他所有的 Web App 全部挂掉（稳定性）
2. 一个 Web App 可以以某种形式访问其他 App 的数据（安全性）

- 多进程设计

1. broswer 进程（主进程）
   负责浏览器的页面展示，与用户交互。如页面的前进，后退，负责页面的管理，创建和销毁其他进程
2. GPU 进程：3D 渲染
3. 插件进程：每种类型的插件对应一个进程，仅当使用该插件时才能创建
4. 浏览器渲染进程（浏览器内核）, 又分为：  
   · GUI 渲染线程：DOM 解析， CSS 解析，生成渲染树  
   · js 引擎线程：执行 Js 代码  
   · 事件触发：管理着一个任务队列  
   · 异步 HTTP 请求线程  
   · 定时触发器线程

- 进程（process）和线程（thread）是操作系统的基本概念。

1. 进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）
2. 线程是 CPU 调度的最小单位（是建立在进程基础上的一次程序运行单位）

## 兄弟选择器

前提: 选择器左右的两个元素必须是有相同的父级  
~: 表示某元素后相邻的兄弟元素，也就是紧挨着的，是单个的  
+: 表示某元素后所有同级的指定元素，强调所有的

## CSS 阴影效果

1、filter: drop-shadow(8px 8px 10px red);  
2、box-shadow: 10px 10px 5px #888888;

## 画三角形

1、border  
2、unicode  
3、正方形旋转  
4、canvas  
5、svg+polygon

## 获得页面所有 DOM 节点

1、document.getElementsByTagName("\*")

## 记录停留时间

[详细](https://zhuanlan.zhihu.com/p/166402090) + 掘金也有类似  
1、多页面应用：进入、刷新和关闭：onload 和 beforeunload；页面跳转也是前两个；前进后退：onpageshow 和 onpagehide 事件记录时长。  
2、单页面应用：进入、刷新和关闭：onload 和 beforeunload；页面跳转和前进后退：history 路由用 onload 和 onpopstate + pushState + replaceState ，hash 路由用 onload 和 onhashchange。其中 history 里跳转是 pushState + replaceState，前进后退是 popstate。  
注：pushState + replaceState 里新的 URL 跟当前的 URL 必须是同源;

## 懒加载/无限滚动

已知有三种实现方法，但原理都是相同的，即判断待加载图片的盒子是否出现在视口中。  
法一：利用 offset、client、scroll 等属性

```js
window.scroll = () => {if (document.documentElement.scrollTop + document.documentElement.clientHeight > div.) loadImg(div)}
```

法二：Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置。

```js
// 大概思路
// 返回值是个对象
const obj = div.getBoundingClientRect();
// if (obj.top < window.innerHeight)
window.scroll = () => {
  if (obj.top < document.documentElement.clientHeight) loadImg(div);
};
```

法三：new intersectionObserver() 自带了节流效果 利用 intersectionRatio > 0 来懒加载  
补充思考：  
1、懒加载/虚拟列表需求优化：
① 触底还没加载出来，添加 loading 解决白屏  
② 瀑布流放置图片的思路(即图片大小不一致时)

## CSS 开发实践(命名等解决方案)

1、less、scss  
2、CSS Module  
3、CSS in JS  
4、tailwind
5、BEM  
6、CSS 原子化  
7、scoped css(之前在去哪儿网 Vue 项目中用过),原理是不同的组件里的元素如 div 有个单独的 key,可以避免命名冲突

## H5 与小程序有什么不同

简单来说：运行平台(小程序在部分 App 中)、开发成本(API 各厂不统一&小程序 API 不够丰富)、发布时间(H5 随时更新/小程序需要审核)，但 H5 要考虑不同浏览器的兼容性  
从技术上来说：  
1、渲染方式：程序一般是通过 Native 原生渲染的，但是小程序同时也支持 web 渲染，如果使用 web 渲染的方式，我们需要初始化一个 webview 组件，然后在 webview 中加载 h5 页面；  
注：小程序下，native 方式通常情况下性能要优于 web 方式。  
2、底层设计：小程序特有的双线程设计。h5 下我们所有资源通常都会打到一个 bundle.js 文件里（不考虑分包加载），而小程序编译后的结果会有两个 bundle，index.js 封装的是小程序项目的 view 层，以及 index.worker.js 封装的是项目的业务逻辑，在运行时，会有两条线程来分别处理这两个 bundle，一个是主渲染线程，它负责加载并渲染 index.js 里的内容，另外一个是 Service Worker 线程，它负责执行 index.worker.js 里封装的业务逻辑，这里面会有很多对底层 api 调用。

## Base64 原理与 API

编码 encode: btoa(stringToEncode) 解码 decode: atob(encodedData)  
Base64 是一种基于 64 个可打印字符来表示二进制数据的表示方法。 由于 2^6=64，所以每 6 个比特为一个单元，对应某个可打印字符。 3 个字节有 24 个比特，对应于 4 个 Base64 单元，即 3 个字节可由 4 个可打印字符来表示。 它不是一种加解密技术，是一种简单的编解码技术。base64 向上取整导致 padding 多余的=号。

## 常用的 CSS 属性及功能实现

- pointer-events: none; (默认值 auto) 鼠标事件穿透下方**图层**

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <style>
      .bottom {
        background: yellow;
        width: 100px;
        height: 100px;
      }

      .top {
        width: 100px;
        height: 100px;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 100;
        display: flex;
        justify-content: center;
        align-items: center;
        /*不再监听当前图层的鼠标事件,而去监听下一层中元素的鼠标事件*/
        pointer-events: none;
      }
      .top b {
        display: inline-block;
        margin: 0 auto;
        /*子元素修改pointer-events，允许触发鼠标事件*/
        pointer-events: auto;
      }
    </style>
  </head>
  <body>
    <!-- 下方div -->
    <div class="bottom">
      <a href="http://www.baidu.com">下一层--百度</a>
    </div>
    <!-- 上方div -->
    <div class="top" onclick="topSay()">
      <b id="topTxt">顶层</b>
    </div>

    <script>
      document.getElementById('topTxt').onclick = function(evt) {
        alert('顶层内b元素的事件！');
        evt.stopPropagation(); //阻止了事件的向上传播，否则就会触发父容器的alert事件。
      };
      function topSay() {
        alert('顶层事件');
      }
    </script>
  </body>
</html>
```

- user-select: none; (默认值 auto) 元素及其子元素的文本不可选中
- white-space (默认值 normal) 设置如何处理元素中的空白
- word-break 与 word-wrap: 都是控制换行的
  word-break:break-all 设置所有文本都换行; word-wrap:break-word 遇到空格或 CJK 文字可能会自动换行，不会强行填充满整行。
  [张鑫旭 blog](https://www.zhangxinxu.com/wordpress/2015/11/diff-word-break-break-all-word-wrap-break-word/)
- word-spacing 设置单词间距(不是汉字)
- 单行/多行省略号

```css
/* 单行： */
.ellipsis {
  width: 200px; /*必须是固定宽度值*/
  overflow: hidden; /*超出部分隐藏*/
  text-overflow: ellipsis; /*超出部分显示省略号*/
  white-space: nowrap; /*规定段落中的文本不进行换行 */
}
```

```css
/* 多行 */
.ellipsis-more {
  width: 200px; /*必须是固定宽度值*/
  display: -webkit-box;
  -webkit-box-orient: vertical; /*垂直分布*/
  -webkit-line-clamp: 3; /*指定三行*/
  overflow: hidden; /*超出部分隐藏*/
  text-overflow: ellipsis;
}
```

- width: 100%; 常用于和父元素宽度保持一致，注意如果是 content-box，子元素可能会溢出父元素  
  content-box：子元素的内容宽度等于父元素的内容宽度，溢出是因为子元素的起点从父元素的内容区开始  
  border-box：子元素的**元素**宽度等于父元素的内容宽度。[分析](https://www.jianshu.com/p/7d565f14f98e)

## HTML 标签属性

- crossOrigin=anonymous 配置跨域请求时，对不同域资源的请求不需要发送凭据  
   | 元素 | 限制 |
  | ---- | ---- |
  | img, audio,video | 当资源被放入 canvas 时，元素被标记为 tainted。 |
  | script | 对错误日志的访问 window.onerror 将受到限制。 |
  | link | 没有适当 crossorigin 标头的请求可能会被丢弃。 |
  [比较全面的分析](https://www.cnblogs.com/wangpenghui522/p/14470760.html)

## DOM 事件

[JS 教程笔记](http://www.souyuncode.com/45.html)

1. “HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。
2. “元素节点的事件属性”的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次 onclick 属性，后一次定义会覆盖前一次。因此，也不推荐使用。
3. EventTarget.addEventListener 是推荐的指定监听函数的方法。它有如下优点：

- 同一个事件可以添加多个监听函数。
- 能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。
- 除了 DOM 节点，其他对象（比如 window、XMLHttpRequest 等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。

## flex 布局

justify-content 属性定义了浏览器之间，如何分配顺着弹性容器主轴 (或者网格行轴) 的元素之间及其周围的空间。  
看 mdn 的示例

```css
justify-content: space-between; /* 均匀排列每个元素
                                   首个元素放置于起点，末尾元素放置于终点 */
justify-content: space-around; /* 均匀排列每个元素
                                   每个元素周围分配相同的空间 */
justify-content: space-evenly; /* 均匀排列每个元素
                                   每个元素之间的间隔相等 */
```

## CSS 动画

1. transition 关注的是 CSS property 的变化，property 值和时间的关系是一个三次贝塞尔曲线。
2. animation 作用于元素本身而不是样式属性，可以使用关键帧的概念，能实现更自由的动画效果。
