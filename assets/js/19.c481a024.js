(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{482:function(t,s,e){"use strict";e.r(s);var a=e(23),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{staticStyle:{"text-align":"center"}},[t._v("talking about Vue.js nextTick")]),t._v("\nVue.js 提供了 2 种调用 nextTick 的方式，一种是全局 API Vue.nextTick，一种是实例上的方法 vm.$nextTick，无论我们使用哪一种，最后都是调用 next-tick.js 中实现的 nextTick 方法。\n"),e("h2",{attrs:{id:"nexttick"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nexttick"}},[t._v("#")]),t._v(" nextTick")]),t._v(" "),e("h3",{attrs:{id:"how"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#how"}},[t._v("#")]),t._v(" how")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// for example")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("openid "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'zbc'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("await")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("$nextTick")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 或者把回调放到()中")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// cb")]),t._v("\n")])])]),e("ul",[e("li",[t._v("cb 将会在 DOM 下次更新之后执行")])]),t._v(" "),e("h3",{attrs:{id:"why"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#why"}},[t._v("#")]),t._v(" why")]),t._v(" "),e("p",[t._v("更新数据后，需要对新 DOM 进行操作，但获取不到更新后的 DOM，因为 DOM 更新是异步的(批处理是微任务)。\n因此 nextTick 设计成微任务，因为想更快地插队从而执行回调(微任务优先级更高)")]),t._v(" "),e("h3",{attrs:{id:"原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),e("p",[t._v("对 cb 进行封装，在不同版本采取不同策略，"),e("a",{attrs:{href:"https://segmentfault.com/a/1190000008589736",target:"_blank",rel:"noopener noreferrer"}},[t._v("一篇好的文章"),e("OutboundLink")],1)]),t._v(" "),e("ul",[e("li",[t._v("2.0-2.4: promise => MutationObserver => setTimeout")]),t._v(" "),e("li",[t._v("2.5: setImmediate => MessageChannel => Promise => setTimeout")]),t._v(" "),e("li",[t._v("2.6: promise => MutationObserver => setImmediate => setTimeout (setImmediate 在浏览器端只支持 IE，约等于 setTimeout(fn,0))\n"),e("img",{attrs:{src:"/blog/assets/img/nexttick.jpeg",alt:"基本渲染场景"}})])]),t._v(" "),e("p",[t._v("那么问题来了，为什么 2.5 要优先封装成宏任务，2.6 为什么又改回去？")]),t._v(" "),e("ul",[e("li",[t._v("2.5 封装成宏任务的原因: 由于 microTask 的执行优先级非常高，在某些场景之下它甚至要比事件冒泡还要快，就会导致一些诡异的问题。")]),t._v(" "),e("li",[t._v("2.6 又改回去的原因：在某些重绘的场景中，会造成页面闪烁。我理解是因为宏任务要晚于 DOM 渲染，因此会出现闪烁。")])])])}),[],!1,null,null,null);s.default=n.exports}}]);