(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{484:function(t,e,a){"use strict";a.r(e);var r=a(23),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"vue-基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-基础"}},[t._v("#")]),t._v(" Vue 基础")]),t._v(" "),a("h2",{attrs:{id:"响应式原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应式原理"}},[t._v("#")]),t._v(" 响应式原理")]),t._v(" "),a("p",[t._v("Observer 类会通过递归的方式把一个对象的所有属性都转化成可观测对象"),a("br"),t._v("\n依赖管理器 Dep 类"),a("br"),t._v("\n数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的 Watch 实例，由 Watcher 实例去通知真正的视图。\n不足:"),a("br"),t._v("\n1.虽然我们通过 Object.defineProperty 方法实现了对 object 数据的可观测，但是这个方法仅仅只能观测到 object 数据的取值及设置值，当我们向 object 数据里添加一对新的 key/value 或删除一对已有的 key/value 时，它是无法观测到的，导致当我们对 object 数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。"),a("br"),t._v("\n2.通过数组下标修改数组中的数据"),a("br"),t._v("\n3.通过修改数组长度清空(改变)数组\n解决:"),a("br"),t._v("\nVue 增加了两个全局 API:Vue.set 和 Vue.delete,更进一步:Proxy")]),t._v(" "),a("h2",{attrs:{id:"路由懒加载-按需加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由懒加载-按需加载"}},[t._v("#")]),t._v(" 路由懒加载(按需加载)")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/smzd/p/8665676.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("三种"),a("OutboundLink")],1),a("br"),t._v("\n非懒加载：")]),t._v(" "),a("p",[t._v("懒加载方式一：使用 import 方法，切换相应的 path 时调用组件")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("List")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'@/components/list.vue'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" router "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("VueRouter")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  routes"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" path"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/list'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" component"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" List "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h2",{attrs:{id:"v-if-和-v-show"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-show"}},[t._v("#")]),t._v(" v-if 和 v-show")]),t._v(" "),a("h2",{attrs:{id:"data-必须为函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data-必须为函数"}},[t._v("#")]),t._v(" data 必须为函数")]),t._v(" "),a("p",[t._v("如果是对象，那么多个组件指向同一个对象，修改一个会导致全部都修改。\n"),a("a",{attrs:{href:"https://www.dazhuanlan.com/ren2012r4/topics/1192478",target:"_blank",rel:"noopener noreferrer"}},[t._v("例子"),a("OutboundLink")],1),t._v("\n如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响;"),a("br"),t._v("\n而 new Vue 的实例(根组件)，是不会被复用的，因此不存在引用对象的问题。"),a("a",{attrs:{href:"https://www.cnblogs.com/lovekunkun/p/12144596.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("例子"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"vue-生命周期函数-钩子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-生命周期函数-钩子"}},[t._v("#")]),t._v(" Vue 生命周期函数/钩子")]),t._v(" "),a("p",[t._v("四个阶段：初始化、模板编译、挂载、卸载\n钩子(hooks): 在特定的动作发生时触发自定义脚本，这个功能就叫钩子 hooks")]),t._v(" "),a("ol",[a("li",[t._v("new Vue(): 执行_init 函数，初始化一些属性：如 initLifecycle、initEvents、initRender，然后执行 beforeCreate")]),t._v(" "),a("li",[t._v("调用 beforeCreate()钩子, 之后初始化 inject、state 包括 props、methods、data、computed、watch，然后执行 created")]),t._v(" "),a("li",[t._v("调用 created()钩子，所以在 created 能拿到 data 等数据，created 之后，"),a("s",[t._v("调用 $mount() 把组件挂载到 dom 上, 然后")]),t._v("对模板进行编译，编译过程: 生成抽象语法树 AST，优化 AST+标记静态节点(因为静态节点不更新,能够优化性能)，根据 AST 生成 render 函数, 然后执行 beforeMount")]),t._v(" "),a("li",[t._v("调用 beforeMount 钩子之后，vm._update(vm._render(), hydrating)，render 方法生成 vnode、而 update 方法会对 vnode 进行 patch，挂载到真实 dom 上，因为是首次，不需要进行新旧节点的 diff(vm._render 用来生成虚拟 dom、执行 dom-diff、更新真实 dom。)")]),t._v(" "),a("li",[t._v("调用 mounted 钩子之后，组件就已经挂载到真实 dom 上，所以可以拿到 dom")]),t._v(" "),a("li",[t._v("beforeUpdate 和 updated 的过程,进行 diff")]),t._v(" "),a("li",[t._v("beforeDestroy 和 destroyed 之间进行组件的销毁操作，比如将自身从父组件中移除、取消依赖追踪、移除所有事件监听器等")])]),t._v(" "),a("h2",{attrs:{id:"vue2-和-vue3-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue2-和-vue3-区别"}},[t._v("#")]),t._v(" Vue2 和 Vue3 区别")]),t._v(" "),a("ol",[a("li",[t._v("响应式原理改为 proxy")]),t._v(" "),a("li",[t._v("diff 优化：最长递增子序列\n")]),t._v(" "),a("li",[t._v("生命周期更改：beforeCreate 和 created 被 setup 替换、beforeDestroy 替换为 beforeUnmount、destroyed 替换为 unmounted(更加语义化)")]),t._v(" "),a("li",[t._v("采用 Fragment: template 可以写多个根元素")]),t._v(" "),a("li",[t._v("更好的 Tree-Shaking"),a("br"),t._v("\nMDN：Tree shaking 是一个通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code) 行为的术语。")]),t._v(" "),a("li",[t._v("更好的支持 TS"),a("br"),t._v("\n总结：更小(tree-shaking)、更快(改用 proxy, 两个优点：性能好无需递归遍历; 不用为数组单独重写原型方法)、维护性高(monorepo 结构)、VDOM Diff 重构(标记静态节点(不需比较)、静态标记?、事件缓存?)、composition API、")]),t._v(" "),a("li",[t._v("应用层上最重要的是 composition API")])]),t._v(" "),a("h2",{attrs:{id:"vue-常见问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-常见问题"}},[t._v("#")]),t._v(" Vue 常见问题")]),t._v(" "),a("ol",[a("li",[t._v("nextTick"),a("br"),t._v("\n由于 dom(数据)的更新是异步的(类比 setState)，Vue 的 this.$nextTick 方法是将执行逻辑放在 dom 更新之后执行，可以拿到最新的 dom/数据，再比如 created 钩子中 dom 还未挂载，那么也可以用这个方法来实现操作 dom。")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.cn/post/6863241580753616903#heading-12",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue 模板编译过程"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://segmentfault.com/a/1190000022248237",target:"_blank",rel:"noopener noreferrer"}},[t._v("keep-alive 缓存组件的原理"),a("OutboundLink")],1)])]),t._v(" "),a("ul",[a("li",[t._v("首次渲染(执行正常的生命周期钩子和 activated)的时候，除了再 "),a("keep-alive"),t._v(" 中建立缓存，设置 vnode.data.keepAlive 为 true，其他的过程和普通组件一样。")],1),t._v(" "),a("li",[t._v("命中缓存进行渲染时，不执行其他钩子，只执行 activated，并且对缓存的组件进行 patch，进行更新。")]),t._v(" "),a("li",[t._v("初始进入和离开 created ---\x3e mounted ---\x3e activated --\x3e deactivated, 后续进入和离开 activated --\x3e deactivated")])]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[a("a",{attrs:{href:"https://juejin.cn/post/6844903890278694919#heading-4",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端路由"),a("OutboundLink")],1)]),t._v(" "),a("li",[t._v("Vue 项目的执行顺序： index.html(模板) => main.js(入口文件) => App.vue(根组件)")])]),t._v(" "),a("h2",{attrs:{id:"vue-与-react-对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-与-react-对比"}},[t._v("#")]),t._v(" Vue 与 React 对比")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6844904158093377549#heading-2",target:"_blank",rel:"noopener noreferrer"}},[t._v("详细"),a("OutboundLink")],1)]),t._v(" "),a("ol",[a("li",[t._v("响应式："),a("br"),t._v("\nVue: 2 里是 defineProperty 和发布订阅模式、3 是 proxy"),a("br"),t._v("\nReact：react 通过 setState 主动触发数据变化。")]),t._v(" "),a("li",[t._v("diff："),a("br"),t._v("\n相同点：同层级 On、唯一 key\nVue 采用双端指针(找到同一 key 的节点，移动即可，复用)，找到新旧节点的位置，边移动指针边对比边更新"),a("br"),t._v("\nReact 是从头开始比对 node，从而去新增、删除或移动节点(没有采用双端指针)"),a("br"),t._v(" "),a("strong",[t._v("传统的 diff")]),t._v("：遍历第一棵树，在第一棵树的遍历中再去遍历第二颗树，找出各个节点 diff 出的结果并记录到一个数组中，这里头操作的时间复杂度是 O(n^2)\n遍历 diff 记录的数组，并对第一棵树的 diff 位置做增删改操作，时间复杂度 O(n)")]),t._v(" "),a("li",[t._v("事件"),a("br"),t._v("\nReact 采用合成事件，所有事件都冒泡到顶层 document 监听，然后在这里合成事件下发")]),t._v(" "),a("li",[t._v("核心思想不同"),a("br"),t._v("\nVue 推崇渐进式开发(灵活易用，只需要使用核心的响应式和 diff 即可开发)、template(静态模板)、三部分分离"),a("br"),t._v("\nReact 推崇函数式开发(hooks)、jsx(动态，更多的是写 js，复杂的 js 逻辑，更适合复杂的 js 逻辑)")])]),t._v(" "),a("h2",{attrs:{id:"vue-样式问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-样式问题"}},[t._v("#")]),t._v(" Vue 样式问题")]),t._v(" "),a("ol",[a("li",[t._v("vue 动态创建的元素的类要单独写一个 style 标签里")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.cnblogs.com/youhong/p/11637695.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("修改第三方组件样式"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"表单输入绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表单输入绑定"}},[t._v("#")]),t._v(" 表单输入绑定")]),t._v(" "),a("p",[t._v("用 v-model 指令在表单 input、textarea 及 select 元素上创建双向数据绑定")]),t._v(" "),a("ul",[a("li",[t._v("text 和 textarea 元素使用 value property 和 input 事件 (文本框，用 input 是因为让其实时触发)")]),t._v(" "),a("li",[t._v("checkbox 和 radio 使用 checked property 和 change 事件 (选择框)")]),t._v(" "),a("li",[t._v("select 下拉框将 value 作为 prop 并将 change 作为事件(下拉框)")])]),t._v(" "),a("p",[t._v("补充：change 事件在"),a("strong",[t._v("失焦")]),t._v("并且内容变化时才触发回调，input 事件是实时触发")]),t._v(" "),a("h2",{attrs:{id:"理解虚拟-dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#理解虚拟-dom"}},[t._v("#")]),t._v(" 理解虚拟 DOM")]),t._v(" "),a("p",[t._v("所有 html 结构，都可以用 js dom 来构造，而且能将构造的步骤封装起来，做到「数据-dom 结构」的映射。缓存初始数据，新数据进来时，与旧数据对比，找到差异，根据差异本身的性质进行 dom 操作；无差异，则不作为。dom 本身在 js 中就是一种数据结构，console.dir(document.body)，在控制台可以看到 body 的数据结构。然而，dom 相关的数据丰富而且复杂，"),a("strong",[t._v("我们其实只关心少数元素的少数属性")]),t._v("。建立一个 javascript plain object，非常轻量，用它保存我们真正关心的与 dom 相关的少数数据；对它进行操作，然后对比操作前后的差异，再根据映射关系去操作真正的 dom，无疑能提高性能。")]),t._v(" "),a("h2",{attrs:{id:"单向数据流和双向绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单向数据流和双向绑定"}},[t._v("#")]),t._v(" 单向数据流和双向绑定")]),t._v(" "),a("ol",[a("li",[t._v("单向数据流：比如父子传值，有利于状态管理，可维护性高")]),t._v(" "),a("li",[t._v("双向绑定：一般用于 UI 组件，v-model")])]),t._v(" "),a("h2",{attrs:{id:"vue-组件间通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-组件间通信"}},[t._v("#")]),t._v(" Vue 组件间通信")]),t._v(" "),a("ol",[a("li",[t._v("父子组件通信：props、emit、refs、children、parent、slot")]),t._v(" "),a("li",[t._v('爷孙组件通信：v-on="listeners"、v-bind="attrs"、provide 和 inject(祖先组件通过 provide 提供数组，后代组件 inject 消费)')]),t._v(" "),a("li",[t._v("跨组件通信：eventbus(发布订阅)、vuex")])]),t._v(" "),a("h2",{attrs:{id:"前端路由"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端路由"}},[t._v("#")]),t._v(" 前端路由")]),t._v(" "),a("p",[t._v("以 vue 为例，称为 vue-router，单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面，要做到：")]),t._v(" "),a("ul",[a("li",[t._v("可以监听到 url 的变化，展示不同内容")]),t._v(" "),a("li",[t._v("改变 url 且不让浏览器像服务器发送请求")])]),t._v(" "),a("h3",{attrs:{id:"hash-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash-模式"}},[t._v("#")]),t._v(" hash 模式")]),t._v(" "),a("ul",[a("li",[t._v("修改#后面的锚点值(location.hash)")]),t._v(" "),a("li",[t._v("通过 window.onhashchange 的方式，来监听 hash 的改变，借此实现无刷新跳转的功能")]),t._v(" "),a("li",[t._v("切换 hash 时不进行请求")])]),t._v(" "),a("h3",{attrs:{id:"history-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#history-模式"}},[t._v("#")]),t._v(" history 模式")]),t._v(" "),a("ul",[a("li",[t._v("利用了 HTML5 History Interface 中新增的 history.pushState() 和 history.replaceState() 方法,分别可以添加和修改历史记录条目。这些方法通常与 window.onpopstate 配合使用。 history.pushState() 和 history.replaceState() 可以"),a("strong",[t._v("改变 url 同时，不会刷新页面")])]),t._v(" "),a("li",[t._v("对于单页应用的 history 模式而言，url 的改变只能由下面四种方式引起：")])]),t._v(" "),a("ol",[a("li",[t._v("点击浏览器的前进或后退按钮")]),t._v(" "),a("li",[t._v("点击 a 标签")]),t._v(" "),a("li",[t._v("在 JS 代码中触发 history.pushState 函数")]),t._v(" "),a("li",[t._v("在 JS 代码中触发 history.replaceState 函数")])]),t._v(" "),a("ul",[a("li",[t._v("给不同的 path 注册对应的回调(加载视图)，切换视图时利用 pushState 和 replaceState 切换 url，触发回调展示不同视图；对于前进后退，利用 popstate 事件监听这些行为，切换不同的视图。")]),t._v(" "),a("li",[t._v("缺点 1：需要注意，在修改 url 后，虽然页面并不会刷新，但我们在手动刷新，或通过 url 直接进入应用的时候， 服务端是无法识别这个 url 的，因为我们是单页应用，只有一个 html 文件，服务端在处理其他路径的 url 的时候，就会出现 404 的情况。所以，如果要应用 history 模式，需要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回单页应用的 html 文件。("),a("strong",[t._v("也就是说需要服务端做好 url 适配")]),t._v(")")]),t._v(" "),a("li",[t._v("缺点 2：兼容性")]),t._v(" "),a("li",[t._v("优点：pushState 和 replaceState 设置的 url 可以是任意同源的 url；新的 url 和原来的 url 一样，也可以添加到历史记录栈中，而 hash 模式对于两个相同的 hash 值不行")])]),t._v(" "),a("h2",{attrs:{id:"vue-过滤器-vue3-已废弃"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-过滤器-vue3-已废弃"}},[t._v("#")]),t._v(" Vue 过滤器(Vue3 已废弃)")]),t._v(" "),a("h2",{attrs:{id:"vue-指令修饰符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-指令修饰符"}},[t._v("#")]),t._v(" Vue 指令修饰符")]),t._v(" "),a("h2",{attrs:{id:"vue-自定义指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-自定义指令"}},[t._v("#")]),t._v(" Vue 自定义指令")])])}),[],!1,null,null,null);e.default=s.exports}}]);